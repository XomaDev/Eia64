; a simple math interpreter that takes in basic expressions and evaluates them in order
; supports +, -, * and /.
; * and / are evaluated first, then + and -
; does not yet support brackets
; * and / are prioritized over + and -

include(
  static:std:string,
  static:std:array
)

let PLUS = "+"
let MINUS = "-"
let DIVIDE = "/"
let MULTIPLY = "*"

let SUPPORTED_OPERATORS = arrayOf(PLUS, MINUS, DIVIDE, MULTIPLY)

fn isNumeric(token: String): Bool {
  if (len(token) == 0) return false
  each (ch in token) {
    if (!("1234567890".contains(str(ch))))
      return false
  }
  return true
}

fn tokenize(expr: String): Array<String> {
  expr = expr.replace("\t", " ")
  until (expr.contains("  "))
    expr = expr.replace("  ", " ")
  return expr.split(" ")
}

var tokens: Array<String> = arrayOf<String>(0, "")
var i = 0
var size = 0

fn isEOF(): Bool = i == size

fn peek(): String = tokens[i]
fn next(): String = tokens[i++]

fn eatNumeric() {
  let value = next()
  if (!isNumeric(value)) {
    println("Expected numeric type token but got " + value)
    exit(1)
  }
  return value
}

fn eatOperator() {
  let op = next()
  if (SUPPORTED_OPERATORS.contains(op))return op
  println("Unknown OP Code: " + op)
  exit(1)
}

fn parse(): Array {
  var left: Any = eatNumeric()
  until (!isEOF()) {
    var op = eatOperator()
    until (op == DIVIDE || op == MULTIPLY) {
      left = arrayOf(left, op, eatNumeric())
      if (isEOF()) break
      else op = next()
    }
    if (isEOF()) break
    let right = parse()
    left = arrayOf(left, op, right)
  }

  ; here we need parser time verification
  ; we need to verify the return values over here
  ; Case when only one single number is typed in, a non-array is returned
  ; which crashes the executor
  return left
}

fn execute(node: Array) {
  var left: Any = node[0]
  let op = node[1]::String
  var right: Any = node[2]

  if (type(left) == "e_array") left = execute(left::Array)
  if (type(right) == "e_array") right = execute(right::Array)

  left = int(left)
  right = int(right)

  return when (op) {
    PLUS -> { left::Int + right::Int }
    MINUS -> { left::Int - right::Int }
    MULTIPLY -> { left::Int * right::Int }
    DIVIDE -> { left::Int / right::Int }
    else -> {
      println("Unknown operator code: " + op)
      exit(1)
    }
  }
}

fn evaluate(expr: String) {
  let lenExpr = len(expr)

  if (lenExpr == 0) {
    println("Empty input!")
  }

  tokens = tokenize(expr)
  i = 0
  size = len(tokens)

  let parsed = parse()
  println(execute(parsed))
}

until (true) {
  print("> ")
  evaluate(readln())
}