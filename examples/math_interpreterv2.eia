include(
  static:std:string,
  static:std:array,
  static:std:math
)

let DELIMITERS = arrayOf("+", "-", "/", "*", "(", ")")
let DELIMITERS_SIZE = DELIMITERS.size()

fn containsDelimiter(expr: String): Bool {
  for (delimiter in DELIMITERS) {
    if (expr.contains(delimiter)) {
      return true
    }
  }
  return false
}

; splitOnce is not called if there's no delimiter remaining!
fn splitOnce(expr: String): Array {
  ; find the nearest possible delimiter
  var nearestDelimiter = 99999999
  for (var i = 0, i < DELIMITERS_SIZE, i++) {
    let index = expr.indexOf(DELIMITERS[i])
    if (index > -1) {
      nearestDelimiter = math.min(nearestDelimiter, index)
    }
  }
  return arrayOf<Any>(
    expr.part(0, nearestDelimiter).trim(),
    str(expr[nearestDelimiter]),
    expr.substring(nearestDelimiter + 1).trim()
  )
}

fn splitRecursive(expr: String): Any {
  if (!containsDelimiter(expr)) return expr
  let splitOnce = splitOnce(expr)
  splitOnce[2] = splitRecursive(splitOnce[2]::String)
  return splitOnce
}

fn tokenize(expr: String): Array<String> {
  ; +, -, *, /, ( and ) are the only possible delimiters
  if (containsDelimiter(expr)) {
    let unflat_array = splitRecursive(expr)::Array
    return unflat_array.flatten(makeArray<String>(unflat_array.recursiveLen(), ""))::Array<String>
  }
  return arrayOf(expr)
}

fn lex(expr: String): Array<String> = tokenize(expr.trim())

var tokens: Array<String> = nil
var index = 0
var size = 0

fn next(): String = tokens[index++]
fn peek(): String {
  println(index + " | " + isEOF())
  let access = tokens[index]
  println("access success")
  return access
}
fn isEOF(): Bool = index == size

fn numeric(): Float = float(next())

fn operator(): Char {
  let operator = next()
  for (delimiter in DELIMITERS) {
    if (delimiter == operator) {
      ; a recognized operator
      return operator[0]
    }
  }
  throw "Unknown operator '" + operator + "'"
  return '_'        ; never reached
}

fn expression(): Any {
  if (peek() == "(") return parse()
  return numeric()
}

fn parse(): Any {
  var left: Any = expression()
  until (!isEOF() && peek() != ")") {
    let op = operator()
    let right = parse()
    left = arrayOf(left, op, right)
  }
  return left
}

fn eval(expr: String) {
  tokens = lex(expr)
  index = 0
  size = len(tokens)
  println(parse())
}

eval("2 + 2")


fn main() {
  eval("2 + 2")
  until (true) {
    let expr = readln().trim()
    if (expr == "break") break
    eval(expr)
  }
}