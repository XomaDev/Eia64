include(
  static:std:string,
  static:std:array,
  static:std:math
)

let DELIMITERS = arrayOf("+", "-", "/", "*", "(", ")")
let DELIMITERS_SIZE = DELIMITERS.size()

fn containsDelimiter(expr: String): Bool {
  for (delimiter in DELIMITERS) {
    if (expr.contains(delimiter)) {
      return true
    }
  }
  return false
}

; splitOnce is not called if there's no delimiter remaining!
fn splitOnce(expr: String): Array {
  ; find the nearest possible delimiter
  var nearestDelimiter = 99999999
  for (var i = 0, i < DELIMITERS_SIZE, i++) {
    let index = expr.indexOf(DELIMITERS[i])
    if (index > -1) {
      nearestDelimiter = math.min(nearestDelimiter, index)
    }
  }
  let delimiterPart = str(expr[nearestDelimiter])
  let firstPart = expr.part(0, nearestDelimiter).trim()
  let lastPart = expr.substring(nearestDelimiter + 1).trim()

  return arrayOf<Any>(
      expr.part(0, nearestDelimiter).trim(),
      str(expr[nearestDelimiter]),
      expr.substring(nearestDelimiter + 1).trim()
    )
}

fn splitRecursive(expr: String): Any {
  if (!containsDelimiter(expr)) return expr
  let splitOnce = splitOnce(expr)
  splitOnce[2] = splitRecursive(splitOnce[2]::String)
  return splitOnce
}

fn fillRecursive(flattened: Array, unflattened: Array, fillIndex: Int) {
  for (element in unflattened) {
    if (element is Array) {
      fillRecursive(flattened, element::Array, fillIndex)
    } else if (!(element::String.isEmpty())) {
      flattened[fillIndex++] = element
    }
  }
}

fn recursiveLen(tokens: Array): Int {
  var size = 0
  for (element in tokens) {
    if (element is Array) size += recursiveLen(element::Array)
    else if (!(element::String.isEmpty())) size++
  }
  return size
}

fn tokenize(expr: String): Array<String> {
  ; +, -, *, /, ( and ) are the only possible delimiters
  if (containsDelimiter(expr)) {
    let unflat_array = splitRecursive(expr)::Array
    let flat_size = recursiveLen(unflat_array)
    let flat_array = makeArray<String>(flat_size, "")

    fillRecursive(flat_array, unflat_array, 0)
    return flat_array
  }
  return arrayOf(expr)
}

fn lex(expr: String): Array<String> = tokenize(expr.trim())

var tokens: Array<String> = nil
var index = 0
var size = 0

fn next(): String = tokens[index++]
fn peek(): String = tokens[index]
fn isEOF(): Bool = index == size

fn numeric(): Float = float(next())

fn operator(): Char {
  let operator = next()
  for (delimiter in DELIMITERS) {
    if (delimiter == operator) {
      ; a recognized operator
      return operator[0]
    }
  }
  throw "Unknown operator '" + operator + "'"
  return '_'        ; never reached
}

fn expression(): Any {
  if (peek() == "(") {
    ; ( eat this one
    ; ) will be eaten by parse()
    next()
    return parse()
  }
  return numeric()
}

fn parse(): Any {
  var left: Any = expression()
  until (!isEOF()) {
    if (peek() == ")") {
      ; just eat and break
      next()
      break
    }
    var op = operator()
    until (op == '/' || op == '*') {
      left = arrayOf(left, op, expression())
      if (isEOF() || peek() == ")") break
      else op = operator()
    }
    if (isEOF()) break
    let right = parse()
    left = arrayOf(left, op, right)
  }
  return left
}

fn execute(node: Any): Float {
  let nodeArray = node::Array
  var left: Any = nodeArray[0]::String
  let op = nodeArray[1]::String
  var right: Any = nodeArray[2]

  if (left is Array) left = execute(left)
  if (right is Array) right = execute(right)

  left = float(left)
  right = float(right)

  return (when (op) {
    '+' -> { left::Float + right::Float }
    '-' -> { left::Float - right::Float }
    '*' -> { left::Float * right::Float }
    '/' -> { left::Float / right::Float }
    else -> {
      println("Unexpected operator '" + op + "'")
      exit(1)
    }
  })::Float
}

fn eval(expr: String) {
  tokens = lex(expr)
  index = 0
  size = len(tokens)
  let parsed = parse()
  println(execute(parsed))
}

println("\nWelcome to math interpreter v2!")

fn main() {
  until (true) {
    print("math> ")
    let expr = readln().trim()
    if (expr == "break") break
    eval(expr)
  }
}