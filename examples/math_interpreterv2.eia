include(
  static:std:string,
  static:std:array,
  static:std:math
)

let DELIMITERS = arrayOf("+", "-", "/", "*", "(", ")")
let DELIMITERS_SIZE = DELIMITERS.size()

fn containsDelimiter(expr: String): Bool {
  for (delimiter in DELIMITERS) {
    if (expr.contains(delimiter)) {
      return true
    }
  }
  return false
}

; splitOnce is not called if there's no delimiter remaining!
fn splitOnce(expr: String): Array {
  ; find the nearest possible delimiter
  var nearestDelimiter = 99999999
  for (var i = 0, i < DELIMITERS_SIZE, i++) {
    let index = expr.indexOf(DELIMITERS[i])
    if (index > -1) {
      nearestDelimiter = math.min(nearestDelimiter, index)
    }
  }
  let delimiterPart = str(expr[nearestDelimiter])
  let firstPart = expr.part(0, nearestDelimiter).trim()
  let lastPart = expr.substring(nearestDelimiter + 1).trim()

  return arrayOf<Any>(
      expr.part(0, nearestDelimiter).trim(),
      str(expr[nearestDelimiter]),
      expr.substring(nearestDelimiter + 1).trim()
    )
}

fn splitRecursive(expr: String): Any {
  if (!containsDelimiter(expr)) return expr
  let splitOnce = splitOnce(expr)
  splitOnce[2] = splitRecursive(splitOnce[2]::String)
  return splitOnce
}

fn fillRecursive(flattened: Array, unflattened: Array, fillIndex: Int) {
  for (element in unflattened) {
    if (element is Array) {
      fillRecursive(flattened, element::Array, fillIndex)
    } else if (!(element::String.isEmpty())) {
      flattened[fillIndex++] = element
    }
  }
}

fn recursiveLen(tokens: Array): Int {
  var size = 0
  for (element in tokens) {
    if (element is Array) size += recursiveLen(element::Array)
    else if (!(element::String.isEmpty())) size++
  }
  return size
}

fn tokenize(expr: String): Array<String> {
  ; +, -, *, /, ( and ) are the only possible delimiters
  if (containsDelimiter(expr)) {
    println("trying to unflat")
    let unflat_array = splitRecursive(expr)::Array
    println("unflat: " + unflat_array)

    let flat_size = recursiveLen(unflat_array)
    let flat_array = makeArray<String>(flat_size, "")
    fillRecursive(flat_array, unflat_array, 0)
    return flat_array
  }
  return arrayOf(expr)
}

fn lex(expr: String): Array<String> = tokenize(expr.trim())

var tokens: Array<String> = nil
var index = 0
var size = 0

fn next(): String = tokens[index++]
fn peek(): String = tokens[index]
fn isEOF(): Bool = index == size

fn numeric(): Float = float(next())

fn operator(): Char {
  let operator = next()
  for (delimiter in DELIMITERS) {
    if (delimiter == operator) {
      ; a recognized operator
      return operator[0]
    }
  }
  throw "Unknown operator '" + operator + "'"
  return '_'        ; never reached
}

fn expression(): Any {
  if (peek() == "(") return parse()
  return numeric()
}

fn parse(): Any {
  var left: Any = expression()
  until (!isEOF() && peek() != ")") {
    let op = operator()
    let right = parse()
    left = arrayOf(left, op, right)
  }
  return left
}

fn eval(expr: String) {
  tokens = lex(expr)
  index = 0
  size = len(tokens)
  println(tokens)
}

eval("62 + (2 * 2)")
eval("53 * 3 / 3 + (2 * 2)")
eval("3242 * (3 + 3) + 3 + (2 * 2)")
eval("223 * (3 + 0 * (34)) + 3 + (2 * 2)")

fn main() {
  eval("2 + (2 * 2)")
  until (true) {
    let expr = readln().trim()
    if (expr == "break") break
    eval(expr)
  }
}